/*
    QueryBuilder.cpp

    
///
/// CBTek LLC ("COMPANY") CONFIDENTIAL
/// Copyright (c) 2016 CBTek, All Rights Reserved.
///
/// NOTICE:  All information contained herein is, and remains the property of COMPANY. The intellectual and technical concepts contained
/// herein are proprietary to COMPANY and may be covered by U.S. and Foreign Patents, patents in process, and are protected by trade secret or copyright law.
/// Dissemination of this information or reproduction of this material is strictly forbidden unless prior written permission is obtained
/// from COMPANY.  Access to the source code contained herein is hereby forbidden to anyone except current COMPANY employees, managers or contractors who have executed
/// Confidentiality and Non-disclosure agreements explicitly covering such access.
///
/// The copyright notice above does not evidence any actual or intended publication or disclosure  of  this source code, which includes
/// information that is confidential and/or proprietary, and is a trade secret, of  COMPANY.   ANY REPRODUCTION, MODIFICATION, DISTRIBUTION, PUBLIC  PERFORMANCE,
/// OR PUBLIC DISPLAY OF OR THROUGH USE  OF THIS  SOURCE CODE  WITHOUT  THE EXPRESS WRITTEN CONSENT OF COMPANY IS STRICTLY PROHIBITED, AND IN VIOLATION OF APPLICABLE
/// LAWS AND INTERNATIONAL TREATIES.  THE RECEIPT OR POSSESSION OF  THIS SOURCE CODE AND/OR RELATED INFORMATION DOES NOT CONVEY OR IMPLY ANY RIGHTS
/// TO REPRODUCE, DISCLOSE OR DISTRIBUTE ITS CONTENTS, OR TO MANUFACTURE, USE, OR SELL ANYTHING THAT IT  MAY DESCRIBE, IN WHOLE OR IN PART.
///

*/
//----------------------------------------
//QueryBuilder.cpp generated by cbtek on 09-24-2016 at 10:13:00 AM
//----------------------------------------
#include "QueryBuilder.h"

#include <sstream>

#include "utility/inc/StringUtils.hpp"
#include "utility/inc/Exception.hpp"
using namespace cbtek::common::utility;

namespace cbtek {
namespace common {
namespace database {

CREATE_EXCEPTION(QueryBuilderException,"QueryBuilderException")

QueryBuilder::QueryBuilder()
{    
}

std::string &QueryBuilder::operator[](const std::string &key)
{
    return m_strMap[key];
}

const std::string &QueryBuilder::operator[](const std::string &key) const
{
    auto itFind = m_strMap.find(key);
    if (itFind != m_strMap.end())
    {
        return itFind->second;
    }
    throw QueryBuilderException(EXCEPTION_TAG+"Could not find key=\""+key+"\"");
}

std::string QueryBuilder::buildQuery(const std::string &rawQuery,
                                     bool caseSensitive) const
{
    std::string query = rawQuery;
    for(const auto &it : m_strMap)
    {
        std::vector<size_t> wholeWords = StringUtils::getWholeWords(query,it.first);
        for(size_t index : wholeWords)
        {
            query.replace(query.begin()+index,query.begin()+index+it.first.size(), it.second);
        }
    }
    return query;
}

void QueryBuilder::clean(const std::string &strToRemove)
{
    for(auto &it : m_strMap)
    {
        it.second = StringUtils::remove(it.second,strToRemove);
    }
}

void QueryBuilder::clear()
{
    m_strMap.clear();
}

QueryBuilder::~QueryBuilder()
{

}

}}}//end namespace


