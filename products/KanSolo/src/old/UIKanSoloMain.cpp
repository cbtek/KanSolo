/*
    UIKanSoloBoard.cpp
    
*/
//UIKanSoloBoard.cpp generated by cbtek on 09-08-2016 at 08:34:55 PM

#include "UIKanSoloBoard.h"
#include "ui_UIKanSoloBoard.h"
#include "utility/inc/FileUtils.hpp"
#include "utility/inc/DateUtils.h"
#include "utility/inc/TimeUtils.h"


#include "KanSoloProjectManager.h"
#include <QDir>
#include "UIKanSoloCreateNewBoard.h"
#include "UIKanSoloCreateNewProject.h"
#include "UIKanSoloCreateNewSprint.h"

#include <QMessageBox>

using namespace cbtek::common::utility;
namespace cbtek {
namespace products {
namespace kan_solo {


UIKanSoloBoard::UIKanSoloBoard(QWidget *parent) :
    QMainWindow(parent),
    m_ui(new Ui_UIKanSoloBoard)
{    
    m_ui->setupUi(this);

    std::vector<KanSoloProject> projects = KanSoloProjectManager::inst().getProjects();
    for (const KanSoloProject& k : projects)
    {
        m_ui->m_cmbProjects->addItem(QString::fromStdString(k.getTitle()));
    }

    connect(m_ui->m_btnNewProject,SIGNAL(clicked(bool)),this,SLOT(onCreateProject()));
    connect(m_ui->m_btnNewBoard,SIGNAL(clicked(bool)),this,SLOT(onCreateBoard()));
    connect(m_ui->m_btnNewSprint,SIGNAL(clicked(bool)),this,SLOT(onCreateSprint()));

}


UIKanSoloBoard::~UIKanSoloBoard()
{
    delete m_ui;
}

void UIKanSoloBoard::loadTasks()
{
    QStringList items = QDir::current().entryList(QStringList()<<"*.task");
    foreach(QString item, items)
    {

    }
}

int UIKanSoloBoard::getNextPosition(int lane)
{
    int row = -1;
    for (int a1= 0;a1<m_ui->m_tblBoard->rowCount();++a1)
    {
        if(m_ui->m_tblBoard->cellWidget(a1,lane))
        {
            continue;
        }
        return a1;
    }

    throw InvalidOperationException(EXCEPTION_TAG+"Could not get valid position from lane!");
}

void UIKanSoloBoard::resizeEvent(QResizeEvent *)
{
//    for (int a1 = 0 ;a1<m_ui->m_tblBoard->rowCount();++a1)
//    {
//        m_ui->m_tblBoard->setRowHeight(a1,m_ui->m_tblBoard->columnWidth(0)/2);
//    }
}

void UIKanSoloBoard::showEvent(QShowEvent *)
{

    m_ui->m_tblBoard->hide();
    resizeEvent(NULL);
}

void UIKanSoloBoard::onCreateTask()
{
    UIKanSoloTask taskUI;
    connect(&taskUI,SIGNAL(taskCreated(KanSoloTask)),this,SLOT(onCreateTask(KanSoloTask)));
    taskUI.exec();
}

void UIKanSoloBoard::onLoadBoard(QString projectId,
                                   QString boardId)
{
//    QString projectId = getProjectId(projectName);
//    QString boardId = getBoardId(projectName,boardName);

    m_ui->m_tblBoard->setColumnCount(4);
    m_ui->m_tblBoard->setRowCount(100);
    m_ui->m_tblBoard->horizontalHeader()->setStyleSheet("QHeaderView{background:#ffffaa;color:black;font-size:28px;}");
    for (size_t a1 = 0;a1<100;++a1)
    {
        m_ui->m_tblBoard->setRowHeight(a1,192);
    }


    std::vector<std::string> filenames;
    //FileUtils::getFileEntries("data/projects/"+projectId+"/"+boardId+"/tasks/",false,true,filenames);
    foreach(std::string file, filenames)
    {
        if (StringUtils::endsWith(file,".task"))
        {
            KanSoloTask task;
            //task.read(file);
            this->onCreateTask(task);
        }
    }


    m_ui->m_tblBoard->setHorizontalHeaderLabels(QStringList() << "TODO"<<"Processing"<<"Testing"<<"Finished");
    m_ui->m_tblBoard->horizontalHeader()->setSectionResizeMode(QHeaderView::Stretch);
    m_ui->m_tblBoard->setVerticalScrollMode(QAbstractItemView::ScrollPerPixel);
    m_ui->m_tblBoard->verticalHeader()->hide();

    connect(m_ui->m_btnNewTask,SIGNAL(clicked(bool)),this,SLOT(onCreateTask()));
    connect(m_ui->m_btnExit,SIGNAL(clicked(bool)),this,SLOT(onClose()));

}



void UIKanSoloBoard::onRemoveTask(const KanSoloTask &task)
{
    //m_ui->m_tblBoard->removeCellWidget(lastPosition,lastLane);
    KanSoloTask deleteTask = task;
    //deleteTask.remove();
}

void UIKanSoloBoard::onUpdateTask(KanSoloTask task)
{
    onRemoveTask(task);
    onCreateTask(task);
}

void UIKanSoloBoard::onCreateProject()
{
    UIKanSoloCreateNewProject project;
    connect(&project,SIGNAL(createProject(QString)),this,SLOT(onCreateProject(QString)));
    project.exec();
}

void UIKanSoloBoard::onCreateProject(const QString &projectName)
{
    KanSoloProject project;
    project.setTitle(projectName.toStdString());
    project.setId(StringUtils::createUUID(true));
    project.setCreationDate(DateUtils::getCurrentDate().toDateInteger());
    project.setCreationTime(TimeUtils::getCurrentTime().toTimeInteger());
    m_currentProject = QString::fromStdString(project.getId());
    KanSoloProjectManager::inst().createProject(project);
}

void UIKanSoloBoard::onCreateBoard(const QString &projectId, const QString &boardName, const QString &backlogLabel, const QString &processingLabel, const QString &testingLabel, const QString &finishedLabel, int maxProcessing, int maxTesting)
{
//    m_currentBoard = QString::fromStdString(KanSoloProjectManager::inst().createBoard(projectId.toStdString(),
//                                                               boardName.toStdString(),
//                                                               backlogLabel.toStdString(),
//                                                               processingLabel.toStdString(),
//                                                               testingLabel.toStdString(),
//                                                               finishedLabel.toStdString(),
//                                                               maxProcessing,
//                                                               maxTesting));
}

void UIKanSoloBoard::onCreateBoard()
{
    if (m_currentProject.isEmpty())
    {
        QMessageBox::information(this,"No Project?","There is no project defined for this board. Please create a project first.");
        return;
    }

    UIKanSoloCreateNewBoard newBoard(m_currentProject);
    connect(&newBoard,
            SIGNAL(createBoard(QString,QString,int,int,int)),
            this,
            SLOT(onCreateBoard(QString,QString,int,int,int)));

    newBoard.exec();
}

void UIKanSoloBoard::onCreateSprint()
{
    UIKanSoloCreateNewSprint newSprint(m_currentProject);
//    connect(&newSprint,
//            SIGNAL(createSprint(QString,QString,int,int,int)),
//            this,
//            SLOT(onCreateSprint(QString,QString,int,int,int)));

    newSprint.exec();
}

void UIKanSoloBoard::onClose()
{
    this->close();
}

void UIKanSoloBoard::onCreateTask(KanSoloTask task)
{
    UIKanSoloTaskTile * tile = new UIKanSoloTaskTile(task);
   // m_tileMap[task.getId()]= tile;
    connect(tile,SIGNAL(promote(KanSoloTask)),this,SLOT(onPromoteTask(KanSoloTask)));
    connect(tile,SIGNAL(demote(KanSoloTask)),this,SLOT(onDemoteTask(KanSoloTask)));
    connect(tile,SIGNAL(remove(KanSoloTask)),this,SLOT(onRemoveTask(KanSoloTask)));
    connect(tile,SIGNAL(edit(KanSoloTask)),this,SLOT(onEditTask(KanSoloTask)));
    //int column = task.getTaskAgileLane();
    //int row = getNextPosition(column);
    //task.setAgileLane(column);
    //task.setAgilePosition(row);
    //task.write();
    //m_ui->m_tblBoard->setCellWidget(row,column,tile);
}

void UIKanSoloBoard::onEditTask(KanSoloTask task)
{
    UIKanSoloTask taskUI(task);
    connect(&taskUI,SIGNAL(taskUpdated(KanSoloTask)),this,SLOT(onUpdateTask(KanSoloTask)));
    taskUI.exec();
}

}}}//end namespace

